# Задача граничного управления для волнового уравнения на звездообразном графе

## О проекте

Данный проект является реализацией выпускной квалификационной работы на тему **"Задача граничного управления для волнового уравнения на звездообразном графе"**.

Цель работы — исследование задачи управляемости для системы, описываемой одномерными волновыми уравнениями на графе с топологией "звезда", и разработка программного комплекса для численного поиска оптимального граничного управления. Найденное управление переводит систему из начального нулевого состояния в заданное конечное состояние при минимизации энергетического функционала.

Проект включает:
*   **Теоретическое обоснование**: Постановка задачи, вывод неравенства наблюдаемости и доказательство теоремы об управляемости системы.
*   **Численная реализация**: Программа на Python, решающая задачу оптимизации методом градиентного спуска.
*   **Визуализация**: Инструменты для демонстрации эволюции системы под действием найденного управления.

### Демонстрация работы

Вот пример анимации, показывающей, как найденное управление переводит систему в целевое состояние. Слева показана эволюция волны на каждом ребре графа, а справа — процесс формирования оптимального управления во времени.

**Пример 1: Задача с известным решением (N=3)**
![Демонстрация работы примера 1](./Assets/example1_optimize.gif)

**Пример 2: Задача со сложными целевыми функциями (N=2)**
![Демонстрация работы примера 2](./Assets/example2_optimize.gif)

---

## Теоретическая основа

### Постановка задачи

Рассматривается задача управления системой из N струн, соединенных в одной точке (топология "звезда"). Динамика каждой струны описывается волновым уравнением:
```math
\begin{cases}
    y_{jtt}(t, x) = y_{jxx}(t, x), \quad t \in (0, T), \quad x \in (0, l_j), \quad j = 1,...,N \\
    y_j(t, 0) = u_j(t) \quad \text{(управление)} \\
    y_j(t, l_j) = y_k(t, l_k) \quad \text{(условие сочленения)} \\
    \sum\limits_{j=1}^N y_{jx}(t, l_j) = 0 \quad \text{(условие Кирхгофа)} \\
    y_j(0, x) = 0, \quad y_{jt}(0, x) = 0 \quad \text{(нулевые начальные условия)}
\end{cases}
```
**Цель:** найти такие управления $u_j(t)$, которые переводят систему в состояние $y_j(T, x) = f_j(x)$ и минимизируют функционал:
```math
J(u) = \sum_{j=1}^N \int\limits_0^{l_j} (y_j(T, x) - f_j(x))^2 \, dx + \lambda\sum_{j=1}^N \int\limits_0^{T} u_j^2(t) \, dt \rightarrow \min
```

### Метод решения

Для решения задачи оптимизации используется **метод градиентного спуска**. Градиент функционала вычисляется с помощью **сопряженного метода**, который требует решения сопряженной задачи для волнового уравнения. Этот подход позволяет эффективно вычислить градиент, не прибегая к дорогостоящим численным методам его аппроксимации.

В работе также приведено **доказательство теоремы об управляемости**, которое гарантирует существование решения задачи при достаточно большом времени управления $T > \max_j l_j$.

---

## Численная реализация

Программный комплекс разработан на языке **Python** с использованием следующих библиотек:
*   **NumPy**: для эффективных векторных вычислений.
*   **Matplotlib**: для визуализации результатов и создания анимаций.
*   **SciPy**: может быть использована для более продвинутых методов оптимизации.

### Структура кода

*   `WaveEquationSolver`: Основной класс, инкапсулирующий всю логику.
    *   `solve_wave_equation_forward()`: Решает прямую задачу для заданного управления $u(t)$.
    *   `solve_wave_equation_backward()`: Решает сопряженную задачу.
    *   `grad_J()`: Вычисляет градиент функционала $J(u)$.
    *   `optimize()`: Реализует метод градиентного спуска для поиска оптимального $u(t)$.
    *   `show_animation()`: Создает и отображает анимацию решения.

Дискретизация уравнений выполнена с помощью **явной разностной схемы "крест"**.

### Как запустить

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/ВАШ_ЛОГИН/ВАШ_РЕПОЗИТОРИЙ.git
    cd ВАШ_РЕПОЗИТОРИЙ
    ```

2.  **Установите зависимости:**
    Убедитесь, что у вас установлен Python 3.x.
    ```bash
    pip install numpy matplotlib
    ```
    Для сохранения анимаций в формате GIF может потребоваться установка дополнительных программ, таких как [ImageMagick](https://imagemagick.org/) или [ffmpeg](https://ffmpeg.org/). Pillow также является хорошей альтернативой.
    ```bash
    pip install Pillow
    ```

3.  **Запустите примеры:**
    В репозитории находятся два основных скрипта, соответствующие примерам из работы:
    ```bash
    python example1.py
    python example2.py
    ```
    Каждый скрипт запустит процесс оптимизации и отобразит анимацию с результатами.

---

## Результаты

Проведенные численные эксперименты подтвердили корректность теоретических выводов и эффективность численного метода.

### Влияние параметров сетки

Исследование сходимости показало, что точность решения сильно зависит от соотношения шагов сетки по времени и пространству ($C = \tau/h$) и от густоты сетки.

![Зависимость погрешности от параметров сетки](src/Figure_1.png)
*Рис. 1. Относительная погрешность численного решения в зависимости от параметра C при разном количестве временных шагов $N_t$.*

Наилучшая точность достигается при значениях $C$, близких к 1, и при использовании достаточно густых сеток.

### Примеры решенных задач

Ниже представлены результаты для двух тестовых примеров. Слева — финальное состояние системы $y_j(T,x)$ (сплошная линия) в сравнении с целевым $f_j(x)$ (пунктир). Справа — найденные оптимальные управления $u_j(t)$.

**Пример 1:**
![Результаты для примера 1](src/Figure_2.png)

**Пример 2:**
![Результаты для примера 2](src/Figure_3.png)

---

## Как создать и вставить GIF-анимацию

Вы можете легко сохранить анимацию, созданную с помощью `FuncAnimation`, в файл.

1.  **Установите Pillow:**
    ```bash
    pip install pillow
    ```

2.  **Измените код для сохранения анимации:**
    В функции `show_animation` (или после ее вызова) добавьте следующий код для сохранения анимации в файл.

    ```python
    # Внутри класса WaveEquationSolver или после создания объекта anim
    # ... (код функции FuncAnimation)
    anim = FuncAnimation(fig, animate, init_func=init, frames=self.Nt + 1,
                         interval=int(self.T * 1000 / self.Nt * speed), blit=True)

    # Сохраняем анимацию в GIF
    print("Сохранение анимации в файл example1.gif...")
    writer = animation.PillowWriter(fps=30) # Указываем количество кадров в секунду
    anim.save('example1.gif', writer=writer)
    print("Сохранение завершено.")

    plt.show()
    ```

3.  **Вставьте GIF в README.md:**
    После того как вы сгенерировали `example1.gif` и `example2.gif` и разместили их в своем репозитории (например, в папке `src` или `assets`), вы можете вставить их в ваш `README.md` файл, используя синтаксис Markdown для изображений:
    ```markdown
    ![Текст, если GIF не загрузится](ПУТЬ/К/ВАШЕМУ/ФАЙЛУ.gif)

    <!-- Пример: -->
    ![Animation Example 1](assets/example1.gif)
    ```

---

## Заключение

Данная работа успешно демонстрирует решение задачи граничного управления для волнового уравнения на графе. Разработанный программный комплекс является гибким инструментом для дальнейших исследований в области управления системами с распределенными параметрами.

## Ссылка на работу

Для более детального ознакомления с теоретической частью, пожалуйста, обратитесь к тексту выпускной квалификационной работы.

*(Здесь вы можете добавить ссылку на PDF-файл с вашей работой, если он будет загружен в репозиторий или размещен на другом ресурсе).*
